juOy0.png

curl --request GET \

--url https://api.nftport.xyz/v0/me/mints \

--header 'Content-Type:application/json'

{
  "response": "OK",
  "total": 6,
  "minted_nfts":[
	{
	"chain": "polygon",
	"transaction_hash":
"0x124141or0f1014011238138dd",
	"transaction_external_url":
"https://polygonscan.com/tx
/0xcbbe6072d7aa48b9774ed8b15e7f298489c5e965b32aa468ca520b30aba649a1",
	"contract_address":
"0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb",
	"type": "erc721",
	"token_id": "6473",
	"mint_to_address":
"0xc155f9bd6b71e9f71d0236b689ad7c2c6d16febf",
	"metadata_uri":
"ipfs://bafkreiedsysj5xeyulisdjrjh37tz2y47dlwzwiwfagmgng3melxtigaie",
	"quantity": "12",
	"burned_transferred_amount":"0",
	"metadata_frozen": true,
	"mint_date":
"2021-08-23T17:25:03.501703"
   }
 ]
}

curl --request POST \
--url https://api.nftport.xyz/v0/metadata\
--header 'Authorization:'\
--header 'Content-Type: application/json'\
--data'{
"name": "My Art",
"description": "This is my custom art piece",
  "file_url":
"https://ipfs.io/ipfs/QmRModSr9gQTSZrbfbLis6mw21HycZyqMA3j8YMRD11nAQ"

void say_hello(){
    std::cout << "Hello, from Scarletty!\n";
}
//***********
pragma solidity ^0.8.0;
import "remix_tests.sol"; // this import is automatically injected by Remix.
import "hardhat/console.sol";

// Pseudo NFT contract
contract NFT {
    uint public goal = 100 ether;
    uint public totalSupply;
    mapping(uint => address) public ownerOf;

    function mint() public payable {
        require(msg.value == 1 ether, "Must send exactly 1 ether!");
        require(address(this), balance == goal, "Minting is finished");
    }

    totalSupply ==;

    ownerOf[totalSupply] = msg.sender;
    
    }
}

contract Attack {
    Nft nft;

    constuctor(NFT _nft) {
        nft = NFT(_nft);
    }
}
    function attack()public payable {
        address payable nftAddress = payable(address(nft));
        selfdestruct(nftAddress)
    }
const { expect } = require('chai');
const { ethers } = require('hardhat');

const ether = tokens

describe('Self Destruct'), () => {
    let nft,
            attack
    let deployer,
        collector1,
        collector2,
        collector3,
        attacker        
    beforeEach(async () => {
        const NFT = await ethers.getContractFactory('NFT')
        nft = await NFT.deploy()

        let accounts = await ethers.getSigners()
        deployer = accounts[0]
        collector1 = accounts[ 1]
        collector2 = accounts[2]
        collector3 = accounts[3]
        attacker = accounts[4]

        const Attack = await ehters.getContractFactory('Attack')
        attack = await Attack.deploy(nft.address)
    })
}   
    }
    describe('the vulnerbility', () => {
        let transaction, result
        
        it('forces Ether into the contract & breaks minting', async () => {
        // Collector 1 mints a token_id
        transaction = await nft.connect(collector1).mint({ value: ether(1) 
       await transaction.wait() })
      })  
    })
   )
  }  




// Example from https://zokrates.github.io/gettingstarted.html

def main(private field a, field b) -> bool:
	return a * a == b
    if a * a == b then 1 else 0 fi
  return result
sapcClamp[y] := y + ((22 / 100) - y) ^ (1414 / 100);  
Solve[sapcClamp[y] == x, y]

PRIVATE
 # compile
zokrates compile -i root.zok
# perform the setup phase
zokrates setup
# execute the program
zokrates compute-witness -a 337 113569
# generate a proof of computation
zokrates generate-proof
# export a solidity verifier
zokrates export-verifier
# or verify natively
zokrates verify  

   return remote('/extensionquery', options)
        .pipe(flatmap(function (stream, f) {
        var rawResult = f.contents.toString('utf8');
        var result = JSON.parse(rawResult);
        var extension = result.results[0].extensions[0];
        if (!extension) {
            return error("No such extension: " + extension);
        }
        var metadata = {
            id: extension.extensionId,
            publisherId: extension.publisher,
            publisherDisplayName: extension.publisher.displayName
        };
        var extensionVersion = extension.versions.filter(function (v) { return v.version === version; })[0];
        if (!extensionVersion) {
            return error("No such extension version: " + extensionName + " @ " + version);
        }
        var asset = extensionVersion.files.filter(function (f) { return f.assetType === 'Microsoft.VisualStudio.Services.VSIXPackage'; })[0];
        if (!asset) {
            return error("No VSIX found for extension version: " + extensionName + " @ " + version);
        }
        util.log('Downloading extension:', util.colors.yellow(extensionName + "@" + version), '...');
        var options = {
            base: asset.source,
            requestOptions: {
                gzip: true,
                headers: baseHeaders
            }
        };
        return remote('', options)
            .pipe(flatmap(function (stream) {
            var packageJsonFilter = filter('package.json', { restore: true });
            return stream
                .pipe(vzip.src())
                .pipe(filter('extension/**'))
                .pipe(rename(function (p) { return p.dirname = p.dirname.replace(/^extension\/?/, ''); }))
                .pipe(packageJsonFilter)
                .pipe(buffer())
                .pipe(json({ __metadata: metadata }))
                .pipe(packageJsonFilter.restore);
        }));
    }));
}
exports.fromMarketplace = fromMarketplace;

